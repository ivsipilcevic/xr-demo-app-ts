export default function (easeLive, config) {
	const Player = config.player;
	const { container, source, hlsjs } = config;
	const instance = config.instance || (hlsjs ? new Player(hlsjs) : new Player());

	function utf8ArrayToStr(array) {
		let out;
		let i;
		let c;
		let char2;
		let char3;

		out = '';
		const len = array.length;
		i = 0;
		while (i < len) {
			c = array[i++];
			switch (c >> 4) {
			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
				// 0xxxxxxx
				out += String.fromCharCode(c);
				break;
			case 12: case 13:
				// 110x xxxx   10xx xxxx
				char2 = array[i++];
				out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
				break;
			case 14:
				// 1110 xxxx  10xx xxxx  10xx xxxx
				char2 = array[i++];
				char3 = array[i++];
				out += String.fromCharCode(((c & 0x0F) << 12)
												| ((char2 & 0x3F) << 6)
												|| ((char3 & 0x3F) << 0));
				break;
			default:
				break;
			}
		}

		return out;
	}

	function handleManifestParsed() {
		container.play();
		easeLive.emit('player.ready', {
			playerContainer: container,
			instance,
		});
	}

	const fragTc = {};
	function handleId3TagTimecodes(event, data) {
		try {
			const encodedTag = data.samples[0].data;
			const parsedTag = utf8ArrayToStr(encodedTag);
			const tcJson = parsedTag.substring(parsedTag.indexOf('{'), parsedTag.indexOf('}') + 1);
			const json = JSON.parse(tcJson);
			const dt = new Date(parseInt(json.ut, 10));
			fragTc[data.frag.sn] = dt.getTime();
		} catch (err) {
			console.error(event, err);
		}
	}

	// TODO trigger tc for each sample in the fragment
	function handleFragChanged(event, data) {
		if (fragTc[data.frag.sn]) {
			easeLive.emit('player.time', {
				timecode: fragTc[data.frag.sn],
			});
		}
	}

	function handleManifestTimecodes(event, data) {
		try {
			if (!data.details.fragments[0].programDateTime) return;

			const diff = container.currentTime - data.details.fragments[0].startPTS;

			const programDateTime = new Date(data.details.fragments[0].programDateTime);
			programDateTime.setSeconds(programDateTime.getSeconds() + diff);

			easeLive.emit('player.time', {
				timecode: programDateTime.getTime(),
			});
		} catch (err) {
			console.error(event, err);
		}
	}

	function handleError(event, data) {
		easeLive.emit('player.error', {
			event,
			data,
			type: data.fatal ? 'fatal' : 'warning',
			message: data.details,
		});
	}

	instance.on(Player.Events.FRAG_PARSING_METADATA, handleId3TagTimecodes);
	instance.on(Player.Events.FRAG_CHANGED, handleFragChanged);
	instance.on(Player.Events.LEVEL_LOADED, handleManifestTimecodes);
	instance.on(Player.Events.MANIFEST_PARSED, handleManifestParsed);
	instance.on(Player.Events.ERROR, handleError);

	function notifyState(state) {
		easeLive.emit('player.state', { state });
	}
	easeLive.on('bridge.ready', () => notifyState(container.paused ? 'paused' : 'playing'));
	const prevOnPlaying = container.onplaying;
	container.onplaying = (e) => {
		if (prevOnPlaying) prevOnPlaying(e);
		notifyState('playing');
	};
	const prevOnPause = container.onpause;
	container.onpause = (e) => {
		if (prevOnPause) prevOnPause(e);
		notifyState('paused');
	};
	const prevOntimeupdate = container.ontimeupdate;
	container.ontimeupdate = (e) => {
		if (prevOntimeupdate) prevOntimeupdate(e);
		easeLive.emit('player.position', {
			position: container.currentTime,
			duration: container.duration,
		});
	};

	instance.loadSource(source);
	instance.attachMedia(container);

	return instance;
}
