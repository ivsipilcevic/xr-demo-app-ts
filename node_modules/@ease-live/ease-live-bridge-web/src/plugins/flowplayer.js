export default function (easeLive, config) {
	const Player = config.player;
	const { container, flowplayer } = config;
	const instance = config.instance || Player(container, flowplayer);

	function utf8ArrayToStr(array) {
		let out;
		let i;
		let c;
		let char2;
		let char3;

		out = '';
		const len = array.length;
		i = 0;
		while (i < len) {
			c = array[i++];
			switch (c >> 4) {
			case 0: case 1: case 2: case 3: case 4: case 5: case 6: case 7:
				// 0xxxxxxx
				out += String.fromCharCode(c);
				break;
			case 12: case 13:
				// 110x xxxx   10xx xxxx
				char2 = array[i++];
				out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));
				break;
			case 14:
				// 1110 xxxx  10xx xxxx  10xx xxxx
				char2 = array[i++];
				char3 = array[i++];
				out += String.fromCharCode(((c & 0x0F) << 12)
												| ((char2 & 0x3F) << 6)
												|| ((char3 & 0x3F) << 0));
				break;
			default:
				break;
			}
		}

		return out;
	}

	function handleManifestParsed() {
		instance.play();
		easeLive.emit('player.ready', {
			playerContainer: container,
			instance,
		});
	}

	const fragTc = {};
	function handleId3TagTimecodes(event, data) {
		try {
			const encodedTag = data.samples[0].data;
			const parsedTag = utf8ArrayToStr(encodedTag);
			const tcJson = parsedTag.substring(parsedTag.indexOf('{'), parsedTag.indexOf('}') + 1);
			const json = JSON.parse(tcJson);
			const dt = new Date(parseInt(json.ut, 10));
			fragTc[data.frag.sn] = dt.getTime();
		} catch (err) {
			console.error(event, err);
		}
	}

	function handleFragChanged(event, data) {
		if (fragTc[data.frag.sn]) {
			easeLive.emit('player.time', {
				timecode: fragTc[data.frag.sn],
			});
		}
	}

	function handleManifestTimecodes(event, data) {
		try {
			if (!data.details.fragments[0].programDateTime) return;

			const diff = container.currentTime - data.details.fragments[0].startPTS;

			const programDateTime = new Date(data.details.fragments[0].programDateTime);
			programDateTime.setSeconds(programDateTime.getSeconds() + diff);

			easeLive.emit('player.time', {
				timecode: programDateTime.getTime(),
			});
		} catch (err) {
			console.error(event, err);
		}
	}

	function handleError(event, data) {
		easeLive.emit('player.error', {
			event,
			data,
			type: data.fatal ? 'fatal' : 'warning',
			message: data.details,
		});
	}

	instance.on('loadedmetadata', handleManifestParsed);
	instance.on('error', handleError);

	function notifyState(state) {
		easeLive.emit('player.state', { state });
	}
	easeLive.on('bridge.ready', () => notifyState(instance.paused ? 'paused' : 'playing'));
	const prevOnPlaying = instance.onplaying;
	instance.onplaying = (e) => {
		if (prevOnPlaying) prevOnPlaying(e);
		notifyState('playing');
	};
	const prevOnPause = instance.onpause;
	instance.onpause = (e) => {
		if (prevOnPause) prevOnPause(e);
		notifyState('paused');
	};
	const prevOntimeupdate = instance.ontimeupdate;
	instance.ontimeupdate = (e) => {
		if (prevOntimeupdate) prevOntimeupdate(e);
		easeLive.emit('player.position', {
			position: instance.currentTime,
			duration: instance.duration,
		});
	};

	// if flowplayer hls plugin is available, attach event listeners for timecode support
	const { hls } = instance;
	if (hls) {
		hls.on('hlsFragParsingMetadata', handleId3TagTimecodes);
		hls.on('hlsFragChanged', handleFragChanged);
		hls.on('hlsLevelLoaded', handleManifestTimecodes);
	}

	return instance;
}
