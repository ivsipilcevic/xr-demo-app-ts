export default function (easeLive, config) {
  var Player = config.player;
  var container = config.container,
      flowplayer = config.flowplayer;
  var instance = config.instance || Player(container, flowplayer);

  function utf8ArrayToStr(array) {
    var out;
    var i;
    var c;
    var char2;
    var char3;
    out = '';
    var len = array.length;
    i = 0;

    while (i < len) {
      c = array[i++];

      switch (c >> 4) {
        case 0:
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
          // 0xxxxxxx
          out += String.fromCharCode(c);
          break;

        case 12:
        case 13:
          // 110x xxxx   10xx xxxx
          char2 = array[i++];
          out += String.fromCharCode((c & 0x1F) << 6 | char2 & 0x3F);
          break;

        case 14:
          // 1110 xxxx  10xx xxxx  10xx xxxx
          char2 = array[i++];
          char3 = array[i++];
          out += String.fromCharCode((c & 0x0F) << 12 | (char2 & 0x3F) << 6 || (char3 & 0x3F) << 0);
          break;

        default:
          break;
      }
    }

    return out;
  }

  function handleManifestParsed() {
    instance.play();
    easeLive.emit('player.ready', {
      playerContainer: container,
      instance: instance
    });
  }

  var fragTc = {};

  function handleId3TagTimecodes(event, data) {
    try {
      var encodedTag = data.samples[0].data;
      var parsedTag = utf8ArrayToStr(encodedTag);
      var tcJson = parsedTag.substring(parsedTag.indexOf('{'), parsedTag.indexOf('}') + 1);
      var json = JSON.parse(tcJson);
      var dt = new Date(parseInt(json.ut, 10));
      fragTc[data.frag.sn] = dt.getTime();
    } catch (err) {
      console.error(event, err);
    }
  }

  function handleFragChanged(event, data) {
    if (fragTc[data.frag.sn]) {
      easeLive.emit('player.time', {
        timecode: fragTc[data.frag.sn]
      });
    }
  }

  function handleManifestTimecodes(event, data) {
    try {
      if (!data.details.fragments[0].programDateTime) return;
      var diff = container.currentTime - data.details.fragments[0].startPTS;
      var programDateTime = new Date(data.details.fragments[0].programDateTime);
      programDateTime.setSeconds(programDateTime.getSeconds() + diff);
      easeLive.emit('player.time', {
        timecode: programDateTime.getTime()
      });
    } catch (err) {
      console.error(event, err);
    }
  }

  function handleError(event, data) {
    easeLive.emit('player.error', {
      event: event,
      data: data,
      type: data.fatal ? 'fatal' : 'warning',
      message: data.details
    });
  }

  instance.on('loadedmetadata', handleManifestParsed);
  instance.on('error', handleError);

  function notifyState(state) {
    easeLive.emit('player.state', {
      state: state
    });
  }

  easeLive.on('bridge.ready', function () {
    return notifyState(instance.paused ? 'paused' : 'playing');
  });
  var prevOnPlaying = instance.onplaying;

  instance.onplaying = function (e) {
    if (prevOnPlaying) prevOnPlaying(e);
    notifyState('playing');
  };

  var prevOnPause = instance.onpause;

  instance.onpause = function (e) {
    if (prevOnPause) prevOnPause(e);
    notifyState('paused');
  };

  var prevOntimeupdate = instance.ontimeupdate;

  instance.ontimeupdate = function (e) {
    if (prevOntimeupdate) prevOntimeupdate(e);
    easeLive.emit('player.position', {
      position: instance.currentTime,
      duration: instance.duration
    });
  }; // if flowplayer hls plugin is available, attach event listeners for timecode support


  var hls = instance.hls;

  if (hls) {
    hls.on('hlsFragParsingMetadata', handleId3TagTimecodes);
    hls.on('hlsFragChanged', handleFragChanged);
    hls.on('hlsLevelLoaded', handleManifestTimecodes);
  }

  return instance;
}