function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

// This BitMovin plugin assumes a global bitmovin variable is available (e.g. loaded via script tag)

/* global bitmovin */
function isHls(player) {
  return player.getStreamType() === 'hls';
}

export default function (easeLive, config) {
  console.log('Installing BitMovin player plugin...');

  var bitmovinConfig = _objectSpread({
    onError: function onError(data) {
      easeLive.emit('player.error', {
        message: data
      });
    }
  }, config.bitmovin);

  var player = config.player;
  var playerContainerId = config.playerContainerId; // Store initial segment time for HLS timecode parsing

  var initialSegmentTime;

  if (!player && typeof bitmovin === 'undefined') {
    easeLive.emit('player.error', {
      type: 'fatal',
      message: 'bitmovin undefined'
    });
    return undefined;
  }

  function ready() {
    easeLive.emit('player.ready', {
      player: player,
      playerContainer: player.getFigure()
    });
  }

  if (player) {
    // we already got a player instance
    ready();
  } else {
    // create a new bitmovin player instance
    player = bitmovin.player(playerContainerId);
    player.setup(bitmovinConfig).then(function () {
      ready();
    }, function (reason) {
      easeLive.emit('player.error', {
        type: 'fatal',
        message: reason
      });
    });
  }

  player.addEventHandler('onTimeChanged', function (e) {
    // In HLS, the time is only relative from the initial segment time
    if (isHls(player)) {
      e.time = e.time * 1000 + initialSegmentTime;
    }

    if (isNaN(e.time)) return;

    if (!isNaN(new Date(e.time * 1000).getTime())) {
      easeLive.emit('player.time', {
        timecode: Math.ceil(e.time * 1000)
      });
    } else {
      easeLive.emit('player.error', {
        type: 'warning',
        message: 'Cannot parse timestamp format from video'
      });
    }
  });
  /**
   * Read initial HLS segment time once to be able to calculate the video
   * position in onTimeChanged
   */

  player.addEventHandler('onSegmentPlayback', function (e) {
    if (isHls(player) && initialSegmentTime === undefined) {
      initialSegmentTime = new Date(e.dateTime).getTime();
    }
  });

  function onPlayerState(state) {
    easeLive.emit('player.state', {
      state: state
    });
  }

  player.addEventHandler('onPlay', function () {
    return onPlayerState('playing');
  });
  player.addEventHandler('onPaused', function () {
    return onPlayerState('paused');
  });
  player.addEventHandler('onStallStarted', function () {
    return onPlayerState('buffering');
  });
  player.addEventHandler('onStallEnded', function () {
    return onPlayerState('playing');
  });
  player.addEventHandler('onTimeShift', function () {
    return onPlayerState('seeking');
  });
  player.addEventHandler('onTimeShifted', function () {
    return onPlayerState('playing');
  }); // return the bitmovin instance

  return player;
}